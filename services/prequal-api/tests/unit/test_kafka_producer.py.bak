"""Unit tests for Kafka producer."""

import json
import sys
from datetime import datetime
from decimal import Decimal
from pathlib import Path
from unittest.mock import AsyncMock, patch
from uuid import UUID, uuid4

import pytest
from aiokafka.errors import KafkaError
from shared.exceptions.exceptions import KafkaPublishError

# Add prequal-api path for app.kafka imports
prequal_api_path = Path(__file__).parent.parent.parent.parent / "services" / "prequal-api"
if str(prequal_api_path) not in sys.path:
    sys.path.insert(0, str(prequal_api_path))

from app.kafka.producer import KafkaJSONEncoder, KafkaProducerWrapper


class TestKafkaJSONEncoder:
    """Test suite for KafkaJSONEncoder."""

    def test_encode_decimal_to_string(self):
        """Test Decimal values are encoded as strings."""
        data = {"amount": Decimal("123.45")}
        result = json.dumps(data, cls=KafkaJSONEncoder)
        assert result == '{"amount": "123.45"}'

    def test_encode_uuid_to_string(self):
        """Test UUID values are encoded as strings."""
        test_uuid = uuid4()
        data = {"id": test_uuid}
        result = json.dumps(data, cls=KafkaJSONEncoder)
        assert f'"{str(test_uuid)}"' in result

    def test_encode_datetime_to_isoformat(self):
        """Test datetime values are encoded as ISO format strings."""
        test_dt = datetime(2024, 1, 1, 12, 0, 0)
        data = {"created_at": test_dt}
        result = json.dumps(data, cls=KafkaJSONEncoder)
        assert "2024-01-01T12:00:00" in result

    def test_encode_complex_nested_object(self):
        """Test encoding complex nested objects with multiple special types."""
        test_uuid = UUID("12345678-1234-5678-1234-567812345678")
        data = {
            "id": test_uuid,
            "amount": Decimal("999.99"),
            "timestamp": datetime(2024, 1, 1),
            "nested": {"value": Decimal("50.25")},
        }
        result = json.dumps(data, cls=KafkaJSONEncoder)
        assert "12345678-1234-5678-1234-567812345678" in result
        assert "999.99" in result
        assert "50.25" in result


class TestKafkaProducerWrapper:
    """Test suite for KafkaProducerWrapper."""

    @pytest.mark.asyncio
    async def test_start_producer_success(self):
        """Test successful producer initialization and startup."""
        with patch("app.kafka.producer.AIOKafkaProducer") as mock_producer_class:
            mock_producer = AsyncMock()
            mock_producer.start = AsyncMock()
            mock_producer_class.return_value = mock_producer

            wrapper = KafkaProducerWrapper()
            await wrapper.start()

            assert wrapper._started is True
            mock_producer.start.assert_awaited_once()

    @pytest.mark.asyncio
    async def test_start_producer_already_started(self):
        """Test starting an already started producer logs warning."""
        wrapper = KafkaProducerWrapper()
        wrapper._started = True

        with patch("app.kafka.producer.logger") as mock_logger:
            await wrapper.start()
            mock_logger.warning.assert_called_once_with("Kafka producer already started")

    @pytest.mark.asyncio
    async def test_start_producer_connection_failure(self):
        """Test producer startup failure raises KafkaPublishError."""
        with patch("app.kafka.producer.AIOKafkaProducer") as mock_producer_class:
            mock_producer_class.side_effect = KafkaError("Connection failed")

            wrapper = KafkaProducerWrapper()
            with pytest.raises(KafkaPublishError) as exc_info:
                await wrapper.start()

            assert "Connection failed" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_stop_producer_success(self):
        """Test successful producer shutdown."""
        mock_producer = AsyncMock()
        mock_producer.stop = AsyncMock()

        wrapper = KafkaProducerWrapper()
        wrapper._producer = mock_producer
        wrapper._started = True

        await wrapper.stop()

        assert wrapper._started is False
        mock_producer.stop.assert_awaited_once()

    @pytest.mark.asyncio
    async def test_stop_producer_not_started(self):
        """Test stopping a producer that was never started."""
        wrapper = KafkaProducerWrapper()
        wrapper._started = False

        with patch("app.kafka.producer.logger") as mock_logger:
            await wrapper.stop()
            mock_logger.warning.assert_called_once_with("Kafka producer not started")

    @pytest.mark.asyncio
    async def test_stop_producer_error_handling(self):
        """Test producer stop handles errors gracefully."""
        mock_producer = AsyncMock()
        mock_producer.stop = AsyncMock(side_effect=Exception("Stop failed"))

        wrapper = KafkaProducerWrapper()
        wrapper._producer = mock_producer
        wrapper._started = True

        with patch("app.kafka.producer.logger") as mock_logger:
            await wrapper.stop()
            mock_logger.error.assert_called_once()

    @pytest.mark.asyncio
    async def test_send_and_wait_success(self):
        """Test successful message publishing."""
        mock_producer = AsyncMock()
        mock_producer.send_and_wait = AsyncMock()

        wrapper = KafkaProducerWrapper()
        wrapper._producer = mock_producer
        wrapper._started = True

        message = {"id": "123", "data": "test"}
        await wrapper.send_and_wait("test-topic", message)

        mock_producer.send_and_wait.assert_awaited_once()

    @pytest.mark.asyncio
    async def test_send_and_wait_with_key(self):
        """Test publishing message with key."""
        mock_producer = AsyncMock()
        mock_producer.send_and_wait = AsyncMock()

        wrapper = KafkaProducerWrapper()
        wrapper._producer = mock_producer
        wrapper._started = True

        message = {"id": "123"}
        await wrapper.send_and_wait("test-topic", message, key="partition-key")

        mock_producer.send_and_wait.assert_awaited_once()

    @pytest.mark.asyncio
    async def test_send_and_wait_not_started(self):
        """Test publishing when producer not started raises error."""
        wrapper = KafkaProducerWrapper()
        wrapper._started = False

        with pytest.raises(KafkaPublishError) as exc_info:
            await wrapper.send_and_wait("test-topic", {"data": "test"})

        assert "not started" in str(exc_info.value).lower()

    @pytest.mark.asyncio
    async def test_send_and_wait_kafka_error(self):
        """Test publishing handles Kafka errors."""
        mock_producer = AsyncMock()
        mock_producer.send_and_wait = AsyncMock(side_effect=KafkaError("Send failed"))

        wrapper = KafkaProducerWrapper()
        wrapper._producer = mock_producer
        wrapper._started = True

        with pytest.raises(KafkaPublishError) as exc_info:
            await wrapper.send_and_wait("test-topic", {"data": "test"})

        assert "Send failed" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_send_and_wait_with_decimal(self):
        """Test publishing message containing Decimal values."""
        mock_producer = AsyncMock()
        mock_producer.send_and_wait = AsyncMock()

        wrapper = KafkaProducerWrapper()
        wrapper._producer = mock_producer
        wrapper._started = True

        message = {"amount": Decimal("123.45"), "id": uuid4()}
        await wrapper.send_and_wait("test-topic", message)

        mock_producer.send_and_wait.assert_awaited_once()

    @pytest.mark.asyncio
    async def test_send_and_wait_with_retries(self):
        """Test send_and_wait with custom retry count."""
        mock_producer = AsyncMock()
        mock_producer.send_and_wait = AsyncMock()

        wrapper = KafkaProducerWrapper()
        wrapper._producer = mock_producer
        wrapper._started = True

        await wrapper.send_and_wait("test-topic", {"data": "test"}, max_retries=5)

        mock_producer.send_and_wait.assert_awaited_once()

    @pytest.mark.asyncio
    async def test_is_started_property(self):
        """Test is_started property returns correct status."""
        wrapper = KafkaProducerWrapper()
        assert wrapper.is_started() is False

        wrapper._started = True
        assert wrapper.is_started() is True
